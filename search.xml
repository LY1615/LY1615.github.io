<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你好 远</title>
    <url>/2023/01/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>奇奇怪怪的事情</category>
      </categories>
      <tags>
        <tag>helloword</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇日志</title>
    <url>/2023/01/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h2><p>这是日志</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序笔记</title>
    <url>/2023/02/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="1.  数据绑定"></a>1.  数据绑定</h2><ol>
<li>小程序<ol>
<li>data中初始化数据</li>
<li>修改数据： this.setData()<ol>
<li>修改数据的行为始终是同步的</li>
</ol>
</li>
<li>数据流： <ol>
<li>单项： Model —&gt; View</li>
</ol>
</li>
</ol>
</li>
<li>Vue<ol>
<li>data中初始化数据</li>
<li>修改数据: this.key &#x3D; value</li>
<li>数据流： <ol>
<li>Vue是单项数据流： Model —&gt; View</li>
<li>Vue中实现了双向数据绑定： v-model</li>
</ol>
</li>
</ol>
</li>
<li>React<ol>
<li>state中初始化状态数据</li>
<li>修改数据: this.setState()<ol>
<li>自身钩子函数中(componentDidMount)异步的</li>
<li>非自身的钩子函数中(定时器的回调)同步的</li>
</ol>
</li>
<li>数据流： <ol>
<li>单项： Model —&gt; View</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-获取用户基本信息"><a href="#2-获取用户基本信息" class="headerlink" title="2. 获取用户基本信息"></a>2. 获取用户基本信息</h2><ol>
<li>用户未授权(首次登陆)<ol>
<li>button open-type&#x3D;‘getUserInfo’</li>
</ol>
</li>
<li>用户已经授权(再次登陆)<ol>
<li>wx.getUserInfo</li>
</ol>
</li>
</ol>
<h2 id="3-前后端交互"><a href="#3-前后端交互" class="headerlink" title="3. 前后端交互"></a>3. 前后端交互</h2><ol>
<li>语法: wx.request()</li>
<li>注意点: <ol>
<li>协议必须是https协议</li>
<li>一个接口最多配置20个域名</li>
<li>并发限制上限是10个</li>
<li><strong>开发过程中设置不校验合法域名</strong>： 开发工具 —&gt; 右上角详情 —-&gt; 本地设置 —&gt; 不校验</li>
</ol>
</li>
</ol>
<h2 id="4-本地存储"><a href="#4-本地存储" class="headerlink" title="4. 本地存储"></a>4. 本地存储</h2><ol>
<li>语法: wx.setStorage() || wx.setStorageSync() || …..</li>
<li>注意点： <ol>
<li>建议存储的数据为json数据</li>
<li>单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB</li>
<li>属于永久存储，同H5的localStorage一样</li>
</ol>
</li>
</ol>
<h1 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h1><h2 id="1-事件流的三个阶段"><a href="#1-事件流的三个阶段" class="headerlink" title="1. 事件流的三个阶段"></a>1. 事件流的三个阶段</h2><ol>
<li>捕获: 从外向内</li>
<li>执行目标阶段</li>
<li>冒泡: 从内向外</li>
</ol>
<h2 id="2-事件委托"><a href="#2-事件委托" class="headerlink" title="2. 事件委托"></a>2. 事件委托</h2><ol>
<li>什么是事件委托<ol>
<li>将子元素的事件委托(绑定)给父元素</li>
</ol>
</li>
<li>事件委托的好处<ol>
<li>减少绑定的次数</li>
<li>后期新添加的元素也可以享用之前委托的事件</li>
</ol>
</li>
<li>事件委托的原理<ol>
<li>冒泡</li>
</ol>
</li>
<li>触发事件的是谁<ol>
<li>子元素</li>
</ol>
</li>
<li>如何找到触发事件的对象<ol>
<li>event.target</li>
</ol>
</li>
<li>currentTarget VS target<ol>
<li>currentTarget要求绑定事件的元素一定是触发事件的元素</li>
<li>target绑定事件的元素不一定是触发事件的元素</li>
</ol>
</li>
</ol>
<h2 id="3-定义事件相关"><a href="#3-定义事件相关" class="headerlink" title="3. 定义事件相关"></a>3. 定义事件相关</h2><ol>
<li>分类<ol>
<li>标准DOM事件</li>
<li>自定义事件</li>
</ol>
</li>
<li>标准DOM事件<ol>
<li>举例： click，input</li>
<li>事件名固定的，事件由浏览器触发</li>
</ol>
</li>
<li>自定义事件<ol>
<li>绑定事件<ol>
<li>事件名</li>
<li>事件的回调</li>
<li>订阅方: PubSub.subscribe(事件名，事件的回调)</li>
<li>订阅方式接受数据的一方</li>
</ol>
</li>
<li>触发事件<ol>
<li>事件名</li>
<li>提供事件参数对象， 等同于原生事件的event对象</li>
<li>发布方: PubSub.publish(事件名，提供的数据)</li>
<li>发布方是提供数据的一方</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><p>1.bindinput实时监测数据变化 chlnye监测数据失去焦点触发变化</p>
<h2 id="微信小程序获取用户openId和加密token"><a href="#微信小程序获取用户openId和加密token" class="headerlink" title="微信小程序获取用户openId和加密token"></a>微信小程序获取用户openId和加密token</h2><p>服务器代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入服务器模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// npm install fly 安装Fly模块</span></span><br><span class="line"><span class="comment">// 引入Fly模块</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Fly</span> = <span class="built_in">require</span>(<span class="string">&quot;flyio/src/node&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fly = <span class="keyword">new</span> <span class="title class_">Fly</span>;</span><br><span class="line"><span class="comment">//引入jsonwebtoken加密模块</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试微信小程序code</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/getOpenId&quot;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> code = req.<span class="property">query</span>.<span class="property">code</span>;</span><br><span class="line">    <span class="keyword">let</span> appId = <span class="string">&quot; &quot;</span> <span class="comment">//自己的appId</span></span><br><span class="line">    <span class="keyword">let</span> appSecret = <span class="string">&quot; &quot;</span> <span class="comment">//自己的appSecret</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">`https://api.weixin.qq.com/sns/jscode2session?appid=<span class="subst">$&#123;appId&#125;</span>&amp;secret=<span class="subst">$&#123;appSecret&#125;</span>&amp;js_code=<span class="subst">$&#123;code&#125;</span>&amp;grant_type=authorization_code`</span></span><br><span class="line">    <span class="comment">// 发请求给微信服务器获取openId</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> fly.<span class="title function_">get</span>(url)</span><br><span class="line">    <span class="keyword">let</span> openId = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(result.<span class="property">data</span>).<span class="property">openid</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;openId&quot;</span>, openId)</span><br><span class="line">    <span class="comment">// 自定义登录态，加密的对象</span></span><br><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&quot;哆啦A梦&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        openId</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对用户的数据进行加密，生成token返回给客户端 </span></span><br><span class="line">    <span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(person,<span class="string">&quot;自己设置密钥&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(token)</span><br><span class="line">    <span class="comment">// 验证身份，反编译token</span></span><br><span class="line">    <span class="keyword">let</span> result2 = jwt.<span class="title function_">verify</span>(token,<span class="string">&quot;自己设置的密钥，用于解密&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line">    res.<span class="title function_">send</span>(token)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器已经启动 http://localhost:3000&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>小程序代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;otherContainer&quot;&gt;</span><br><span class="line">  &lt;!-- 测试用户的唯一标识openId --&gt;</span><br><span class="line">  &lt;view&gt;----------------------我是分割线----------------------&lt;/view&gt;</span><br><span class="line">  &lt;view class=&quot;otherTitle&quot;&gt;测试用户的唯一标识&lt;/view&gt;</span><br><span class="line">  &lt;button bindtap=&quot;handleGetOpenId&quot;&gt;获取openId&lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//获取用户openId</span></span><br><span class="line">  <span class="comment">// 密钥：</span></span><br><span class="line">  <span class="title function_">handleGetOpenId</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.获取登录凭证</span></span><br><span class="line">    wx.<span class="title function_">login</span>(&#123;</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">async</span> (res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// console.log(res)</span></span><br><span class="line">        <span class="keyword">let</span> code = res.<span class="property">code</span>;</span><br><span class="line">        <span class="keyword">let</span> result  =<span class="keyword">await</span>  <span class="title function_">requset</span>(<span class="string">&quot;/getOpenId&quot;</span>,&#123;code&#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//2.将登录凭证发送给服务器</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onReady</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面显示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onShow</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面隐藏</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onHide</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onUnload</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面相关事件处理函数--监听用户下拉动作</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onPullDownRefresh</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面上拉触底事件的处理函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onReachBottom</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用户点击右上角分享</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">onShareAppMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise笔记</title>
    <url>/2022/10/23/Promise/</url>
    <content><![CDATA[<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><ul>
<li>fs 文件操作</li>
<li>数据库操作</li>
<li>AJAX</li>
<li>定时器</li>
</ul>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul>
<li>在js中，通常情况下代码都是同步执行的</li>
<li>异步执行代码时，当遇到需要其他进程处理的工作时，js不需要等待，而是继续执行其他代码，直到其他进程处理完毕后js再继续之前的工作</li>
<li>异步问题：1.不能直接通过return设置返回值(通过回调函数解决) 2.回调地狱(增加代码的复杂，不易维护)</li>
<li>哪些代码执行速度慢1.向服务器发送请求的代码2.Ajax(异步的js和XML)</li>
</ul>
<h2 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h2><p>实例对象中的一个属性 PromiseState</p>
<ul>
<li>pending 未决定的</li>
<li>resolved &#x2F; fullfilled 成功</li>
<li>rejected 失败</li>
</ul>
<h2 id="Promise对象的值"><a href="#Promise对象的值" class="headerlink" title="Promise对象的值"></a>Promise对象的值</h2><p>实例对象中的另外一个属性 PromiseResult<br>保存对象成功和失败的结果</p>
<ul>
<li>resolve</li>
<li>reject</li>
</ul>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>尚品汇项目笔记</title>
    <url>/2023/02/15/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="项目配置分析"><a href="#项目配置分析" class="headerlink" title="项目配置分析"></a>项目配置分析</h2><p>node_modules文件夹:项目依赖文件夹。<br>public文件夹:一般放置一些静态资源(图片)，需要注意，放在public文件夹中的静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。<br>src文件夹(源代码文件夹):<br>assets文件夹:一般也是放置静态资源(一般放置多个组件共用的静态资源)，需要注意，放置在assest文件夹里面静态资源，webpack进行打包的时候会把静态资源当作一个模块，打包js文件里面，在样式当中也可以使用~@(代表的src文件)<br>components文件夹:一般放置的是非路由组件(全局组件)。<br>api文件：存放项目API<br>App.vue:唯一的根组件，vue当中的组件(.vue)<br>main.js:程序的入口文件，也是整个程序当中最先执行的文件<br>babel.config.js:配置文件(babel相关)。<br>package.json文件:记录配置信息。<br>package-lock.json:锁定安装版本的文件。保证包一致性版本。<br>README.md:说明文件。</p>
<h2 id="项目的-其他配置"><a href="#项目的-其他配置" class="headerlink" title="项目的 其他配置"></a>项目的 其他配置</h2><p>1.eslint纠错功能关闭:在vue.config.js里面配置这段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">lintOnSave</span>: <span class="literal">false</span> <span class="comment">//关闭语法检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.jsconfig.json:别名@提示 不能用在”node_modules”,”dist”文件中。</p>
<h2 id="项目路由的分析"><a href="#项目路由的分析" class="headerlink" title="项目路由的分析"></a>项目路由的分析</h2><p>key:URL(地址栏中的路径)<br>value:相应的路由组件<br>注意：项目上中下结构<br>路由组件:<br>Home首页路由组件、Search路由组件、Login登录路由组件、Refister注册路由组件<br>非路由组件:<br>Header组件:首页、搜索页面<br>Footer组件:首页、搜索页面，但是在 登录和注册页面没有</p>
<h2 id="组件的使用（非路由组件）"><a href="#组件的使用（非路由组件）" class="headerlink" title="组件的使用（非路由组件）"></a>组件的使用（非路由组件）</h2><p>1.创建或者定义<br>2.引入<br>3.注册<br>4.使用</p>
<h2 id="全局组件的使用"><a href="#全局组件的使用" class="headerlink" title="全局组件的使用"></a>全局组件的使用</h2><p>1.什么时候使用：在项目中要多次使用<br>2.放在components文件夹下<br>3.要保证HTML,CSS,JS代码一致才能注册全局组件</p>
<h2 id="路由组件的搭建"><a href="#路由组件的搭建" class="headerlink" title="路由组件的搭建"></a>路由组件的搭建</h2><p>1.components文件夹：一般放置的是非路由组件(共用全局组件)<br>2.pages | views文件夹：一般放置的是路由组件<br>3.项目当中配置的路由一般放置在router文件中<br>4.$route:一般获取路由信息[路径，query，params等等]<br>5.$router:一般进行编程式导航进行路由跳转[push | replace]<br>6.路由组件还是非路由组件身上都有$route和$router</p>
<h2 id="路由的跳转"><a href="#路由的跳转" class="headerlink" title="路由的跳转"></a>路由的跳转</h2><p>1.声明式导航router-link，可以进行路由的跳转<br>2.编程式导航$router.push | replace，可以进行路由的跳转<br>3.声明式导航：声明式导航能做的，编程式导航都能做，但是编程式导航除了可以进行路由跳转，还可以做一些其他的业务逻辑<br>4.配置路由的时候，可以给路由添加元信息[meta],路由需要配置对象，它的key不能随便写<br>5.声明式导航没有：当跳转到当前路由参数不变的时候，多次执行会产生NavigationDuplicated报错？</p>
<h2 id="编程式导航的问题"><a href="#编程式导航的问题" class="headerlink" title="编程式导航的问题"></a>编程式导航的问题</h2><p>1.当跳转到当前路由参数不变的时候，多次执行会产生NavigationDuplicated报错？而声明式导航没有<br>答：<br>1.1.原因：”vue-router”: “^3.5.3”：引入了promise<br>1.2.this：当前组件实例(search)<br>this.$router属性：当前的这个属性，属性值VueRouter类的一个实例，当在入口文件注册路由的时候，给组件实例添加$router | $router<br>push：VueRouter类的一个实例<br>1.3.解决方法1：重写originPush和originReplace方法<br>解决方法2：直接在this.$router.push写成功和失败的回调<br>1.4.call || apply区别<br>相同点：都可以调用函数一次，都可以篡改函数的上下文一次<br>不同点：call传递参数用逗号隔开，apply方法执行，传递数组</p>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>1.params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位<br>2.query参数：不属于路径当中的一部分，类似于ajax的queryString，例子：&#x2F;home?k&#x3D;1&amp;kv&#x3D;2，不需要占位</p>
<h2 id="静态页面模块拆分"><a href="#静态页面模块拆分" class="headerlink" title="静态页面模块拆分"></a>静态页面模块拆分</h2><p>1.先把静态页面完成<br>2.拆分出静态组件<br>3.获取服务器的数据进行展示(api)<br>4.vuex(三连环)<br>4.动态展示数据<br>5.注意：HTML + CSS + 图片资源，缺一不可，一定要细心</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1.常用的方式<br>XMLHttpRequest，fetch，jq，axios<br>2.为什么需要进行二次封装axios？<br>请求拦截器，响应拦截器：请求拦截器，可以在发送请求之前处理一些业务，响应拦截器，当服务器数据返回以后，可以处理一些业务<br>3.接口统一管理<br>项目很小：完全可以在组件的生命周期函数中发请求<br>项目很大：axios.get(“xxx”)</p>
<h2 id="Vuex状态管理库"><a href="#Vuex状态管理库" class="headerlink" title="Vuex状态管理库"></a>Vuex状态管理库</h2><p>1.Vuex是什么？</p>
<ul>
<li>Vuex是官方提供一个插件，状态管理库，集中式管理项目中组件共用的数据<br>2.Vuex实现模块式开发</li>
<li>如果项目过大，组件过多，接口有很多，数据也很多，可以让Vuex实现模块式开发</li>
<li>Vuex存储的数据不是持久化的</li>
<li>组件当中获取仓库中的数据：this.$store.state.仓库名称.。</li>
<li>回调函数中使用：store.state.仓库名称.。</li>
</ul>
<h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><ul>
<li>节流：连续触发事件但是在 n 秒中只执行一次函数。(就是技能CD,CD没好,你用不了技能)</li>
<li>防抖：触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。(就是回城,被打断就要重新来)</li>
</ul>
<h2 id="动画和过渡"><a href="#动画和过渡" class="headerlink" title="动画和过渡"></a>动画和过渡</h2><p>过渡动画：前提组件 | 元素必须要有v-if | v-show指令才可以进行过渡动画</p>
<h2 id="mock数据-模拟"><a href="#mock数据-模拟" class="headerlink" title="mock数据(模拟)"></a>mock数据(模拟)</h2><p>使用mock：<br>1.下载插件 npm install mockjs<br>2.在项目当中src文件夹中创建mock文件夹<br>3.在mock文件夹下准备JSON数据(记得格式化)<br>4.把mock数据需要的图片放到public文件夹中(在打包的时候public会原封不动的打包到dist文件夹中)<br>5.创建mockServe.js通过mockjs插件实现模拟数据<br>6.mockServe.js文件在入口文件中引入(至少需要执行一次，才能模拟数据)</p>
<h2 id="swiper技术的使用"><a href="#swiper技术的使用" class="headerlink" title="swiper技术的使用"></a>swiper技术的使用</h2><p>1.引包(js和css)文件，npm使用：npm i swiper@5<br>2.页面结构必须要有<br>3.必须在页面结构中有的情况下，再初始化Swiper</p>
<h2 id="vue-nextTick"><a href="#vue-nextTick" class="headerlink" title="vue.nextTick"></a>vue.nextTick</h2><p>nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<br>nextTick：可以保证页面中的解构一定有的，经常和很多插件一样使用(都需要DOM存在)<br>v-for也可以在自定义标签当中使用</p>
<h2 id="组件通信的方式-面试频率高"><a href="#组件通信的方式-面试频率高" class="headerlink" title="组件通信的方式(面试频率高)"></a>组件通信的方式(面试频率高)</h2><p>1.消息订阅发布（全能） ：，<br>2.全局事件总线（全能）：this.$bus.$emit（自定义名字）<br>this.$bus.$on(“自定义名字”,()&#x3D;&gt;{</p>
<p>})<br>3.props（父传子组件通信）：:属性名&#x3D;”属性值”，props使用的是属性名(写法：数组，对象，函数)<br>4.自定义事件（子传父通信）：@自定义名称 @emit，<br>5.插槽：，<br>6.vuex：，</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>升序就是从小到大。<br>降序就是从大到小。</p>
<h2 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h2><p>1.为什么需要分页器?<br>当后台传入了大量的数据，那么在前端拿到数据，如果直接展示很有可能或造成卡顿，同时消耗过多的内存，给用户带来的浏览效果就不好。<br>2.需要知道什么?<br>需要知道当前是第几个：pageNo字段代表当前页数<br>需要知道每一页需要展示多少条数据：pageSize字段进行代表<br>需要知道整个分页器一共有多少条数据：total字段进行代表<br>需要知道分页器连续页码个数：continues字段进行代表<br>为什么是5 | 7[奇数]?因为对称好看<br>3.总页数(totalPage)&#x3D;总数据量&#x2F;每页展示数量<br>重要的地方：计算出连续页面起始数字和结束数字</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>浏览器存储功能：HTML5中新增的<br>本地存储：持久化(5M)，<br>会话存储(用于一些简单的数据)：页面关闭，数据消失<br>一般存储的是字符串</p>
<h2 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h2><p>1.注册：通过数据库存储用户的信息(名字，密码)<br>2.token(令牌：唯一标识符)<br>3.登录：登录成功的时候，后台为了区分用户是谁，服务器会发送一个token(令牌)，前台持久化存储(带着token找服务器要用户信息进行展示)</p>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>1.导航：表示路由正在发生变化，进行路由跳转<br>2.守卫：满足条件放行<br>3.全局守卫：全局解析守卫，全局后置守卫。<br>3.1.全局前置守卫(<br>to：获取跳转到那个路由的信息<br>from：可以获取到从那个路由来的<br>next：放行函数，使用：1.next()放行，2.next(“&#x2F;login”)放行到什么地方，3.next(false)此路不通，原路返回)<br>4.路由独享的守卫：<br>5.组件内的守卫：</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>不能在生命周期函数中使用async、await<br>因为加了async  周期函数 就不是同步的  变成异步函数  生命周期就无法按照预定顺序完成  造成非预期的效果</p>
<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>npm i <a href="mailto:&#x76;&#117;&#x65;&#x2d;&#108;&#x61;&#122;&#121;&#108;&#111;&#97;&#x64;&#x40;&#x31;&#46;&#x33;&#46;&#51;">&#x76;&#117;&#x65;&#x2d;&#108;&#x61;&#122;&#121;&#108;&#111;&#97;&#x64;&#x40;&#x31;&#46;&#x33;&#46;&#51;</a></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>vue插件暴露的是一个对象</p>
<h2 id="正则插件使用"><a href="#正则插件使用" class="headerlink" title="正则插件使用"></a>正则插件使用</h2><p>npm i vee-validate@2 –save</p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。<br>使用：component: () &#x3D;&gt; import(‘路由’),</p>
<h2 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h2><p>打包：npm run build<br>map文件是用来找bug的，项目不需要可以清除<br>清除Map文件<br>productionSourceMap:false</p>
<h2 id="linux基本操作"><a href="#linux基本操作" class="headerlink" title="linux基本操作"></a>linux基本操作</h2><p>1.&#x2F;根目录<br>2.cd：跳转目录<br>3.ls： 查看<br>4.mkdir：创建目录<br>4.pwd：查看绝对路径</p>
<h2 id="nginx方向代理"><a href="#nginx方向代理" class="headerlink" title="nginx方向代理"></a>nginx方向代理</h2><p>1.进入etc目录，安装nginx：yum install nginx</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/2023/04/25/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>注意:组件通信在你们将来面试的时候出现频率超级高。<br>前面基础的时候：组件通信讲了6种？</p>
<p>组件通信方式1：props<br>使用场景:[父子通信]<br>传递数据类型：<br>1:可能是函数  ———–实质子组件想给父亲传递数据<br>2:可能不是函数———–实质就是父亲给子组件传递数据<br><TodoList :todos="123"  updateChecked="hander"></p>
<p>特殊情况：路由传递props<br>1:布尔值类型，把路由中params参数映射为组件props数据<br>2:对象，静态数据，很少用<br>3:函数，可以把路由中params|query参数映射为组件props数据</p>
<p>组件通信方式2:自定义事件   $emit  $on[简写@]<br>事件:原生DOM事件—-【click|mouseenter……..】<br>事件：自定义事件—–[子给父传递数据]</p>
<p>组件通信方式3：$bus 全局事件总线—-【万能】<br>组件实例的原型的原型指向的Vue.prototype</p>
<p>组件通信方式4：pubsub-js【发布订阅消息】*****在vue中根本不用【React】 —-万能</p>
<p>组件通信方式5:Vuex[仓库]  —–数据非持久化—-万能的</p>
<p>核心概念：5<br>state<br>mutations<br>actions<br>getters<br>modules</p>
<p>组件通信方式6：插槽—–父子通信【结构】<br>slot</p>
<p>默认插槽<br>具名插槽<br>作用域插槽:子组件的数据来源于父组件，但是子组件的自己的结构有父亲决定。</p>
<p>watch|computed|method区别?<br>{<br>    name:’王二麻子’,<br>    eat:function(){</p>
<pre><code>&#125;
</code></pre>
<p>}</p>
<p>1:事件相关的深入学习</p>
<p>事件:事件已经学习过两种，第一种原生DOM事件，第二种自定义事件。</p>
<p>&lt;Event1 @click&#x3D;”handler1”&gt;</Event1><br>组件绑定原生DOM事件，并非原生DOM事件，而是所谓的自定义事件。<br>如果你想把自定义事件变为原生DOM事件，需要加上修饰符.native修饰<br>这个修饰符，可以把自定义事件【名字：原生DOM类型的】变为原生DOM事件，</p>
<p>7:v-model实现组件通信？</p>
<p>v-model：指令，可以收集表单数据【text、radio、checkbox、range】等等<br>切记：v-model收集checkbox需要用数组收集</p>
<p>v-model:实现原理   :value  @input  还可以实现父子数据同步。<br><CustomInput v-model="msg"></CustomInput></p>
<p>8:属性修饰符.sync，可以实现父子数据同步。<br>以后在elementUI组件中出现，实现父子数据同步。</p>
<p>9：$attrs与$listeners   —-vue-helper  父子组件通信<br>$attrs：组件实例的属性，可以获取到父亲传递的props数据（前提子组件没有通过props接受）<br>$listeners：组件实例的属性，可以获取到父亲传递自定义事件（对象形式呈现）</p>
<p>10:$children与$parent       可以实现父子组件通信<br>ref:可以在父组件内部获取子组件—实现父子通信<br>$children:可以在父组件内部获取全部的子组件【返回数组】<br>$parent:可以在子组件内部获取唯一的父组件【返回组件实例】</p>
<p>第一种:props —-父子<br>1:父子通信，props只读的<br>2：写法三种【todos】 {todos：Array} {todos：{type:Arrat,default:[]}}<br>3：路由props</p>
<p>第二种:自定义事件<br>1：子给父传递数据<br>2：两种【简单写法|复杂写法】<br>&lt;Todos @erha&#x3D;”handler”&gt;<br><Todos ref='erha'><br>mounted(){<br>  this.$refs.erha.$on(‘xx’,callBack)<br>}</p>
<p>3:全局事件总线  —万能<br>4：pubsub-js——万能<br>5：vuex——万能<br>6：v-model<br>7：.sync<br>8:$attrs|$listeners<br>9:$children|$parent    —-ref</p>
<p>10插槽 ——用于插槽<br>插槽：父子组件通信（HTML结构）<br>插槽slot：<br>默认插槽|具名插槽|作用于插槽<br>作用域插槽:子组件的数据来源于父组件，但是子组件决定不了自身结构与外观。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>尚品汇后台管理系统</title>
    <url>/2023/04/27/%E5%B0%9A%E5%93%81%E6%B1%87%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="什么是后台管理系统？"><a href="#什么是后台管理系统？" class="headerlink" title="什么是后台管理系统？"></a>什么是后台管理系统？</h2><p>可以让用户通过一个可视化工具，可以实现对于数据库进行增删改查的操作。<br>而且需要注意，根据不同的角色（老板、员工），看到的、操作内容是不同的。<br>对于后台管理系统项目，一般而言，是不需要注册的。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>build<br>     —-index.js webpack配置文件【很少修改这个文件】<br>mock<br>    —-mock数据的文件夹【模拟一些假的数据mockjs实现的】，因为咱们实际开发的时候，利用的是真是接口<br>node_modules<br>     ——项目依赖的模块<br>public<br>     ——ico图标,静态页面，publick文件夹里面经常放置一些静态资源，而且在项目打包的时候webpack不会编译这个文件夹，原封不动的打包到dist文件夹里面<br>src<br>    —–程序员源代码的地方<br>    ——api文件夹:涉及请求相关的<br>    ——assets文件夹：里面放置一些静态资源（一般共享的），放在aseets文件夹里面静态资源，在webpack打包的时候，会进行编译<br>    ——components文件夹：一般放置非路由组件获取全局组件<br>    ——icons这个文件夹的里面放置了一些svg矢量图<br>    ——layout文件夹：他里面放置一些组件与混入<br>    ——router文件夹：与路由相关的<br>    —–store文件夹：一定是与vuex先关的<br>    —–style文件夹：与样式先关的<br>    ——utils文件夹：request.js是axios二次封装文件****<br>    ——views文件夹：里面放置的是路由组件<br>App.vue:根组件<br>main.js：入口文件<br>permission.js:与导航守卫先关、<br>settings：项目配置项文件<br>.env.development<br>.env.producation</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.Vue.set( target, propertyName&#x2F;index, value )]<br>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property</p>
<p>2.当页面来不及渲染的时候，使用$nextTick解决</p>
<p>3.深度选择器(用于加了scoped样式穿透)</p>
<p>3.1：&gt;&gt;&gt; 一般用于原生CSS</p>
<p>3.2：&#x2F;deep&#x2F; 一般用于less</p>
<p>3.3：::v-deep 一般用户scss</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript笔记</title>
    <url>/2023/09/10/TypeScript%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>1.将来不能将其他类型的值赋予这个变量<br>2.代码有提示，在变量后面可以直接看到当前类型所支持的所有属性和方法</p>
<h2 id="interface-对比-type"><a href="#interface-对比-type" class="headerlink" title="interface 对比 type"></a>interface 对比 type</h2><p>相同点：都可以给对象指定类型<br>不同点：<br>        1.接口，只能为对象指定类型<br>        2.类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名</p>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>可以实现让一个接口使用另一个接口的类型约束，实现接口的复用</p>
<h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>字面量类型就是把字面量当作类型来使用</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是可以在保证类型安全的前提下，让函数等与多种类型一起工作，从而实现复用</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux笔记</title>
    <url>/2024/03/23/Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><ul>
<li><code>i</code> – 切换到输入模式，在光标当前位置开始输入文本。</li>
<li><code>x</code> – 删除当前光标所在处的字符。</li>
<li><code>:</code> – 切换到底线命令模式，以在最底一行输入命令。</li>
<li><code>a</code> – 进入插入模式，在光标下一个位置开始输入文本。</li>
<li><code>o</code>：在当前行的下方插入一个新行，并进入插入模式。</li>
<li><code>O</code> – 在当前行的上方插入一个新行，并进入插入模式。</li>
<li><code>dd</code> – 剪切当前行。</li>
<li><code>yy</code> – 复制当前行。</li>
<li><code>p</code>（小写） – 粘贴剪贴板内容到光标下方。</li>
<li><code>P</code>（大写）– 粘贴剪贴板内容到光标上方。</li>
<li><code>u</code> – 撤销上一次操作。</li>
<li><code>Ctrl + r</code> – 重做上一次撤销的操作。</li>
<li><code>:w</code> – 保存文件。</li>
<li><code>:q</code> – 退出 Vim 编辑器。</li>
<li>*<code>q!</code> – 强制退出Vim 编辑器，不保存修改。</li>
</ul>
<p>在命令模式下按下 <strong>i</strong> 就进入了输入模式，使用 <strong>Esc</strong> 键可以返回到普通模式。</p>
<ul>
<li><p><code>:w</code>：保存文件。</p>
</li>
<li><p><code>:q</code>：退出 Vim 编辑器。</p>
</li>
<li><p><code>:wq</code>：保存文件并退出 Vim 编辑器。</p>
</li>
<li><p><code>:q!</code>：强制退出Vim编辑器，不保存修改。</p>
</li>
</ul>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>查看状态：systemctl status firewalld<br>关闭：systemctl stop firewalld<br>关闭防火墙开机自启动：systemctl disable firewalld</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>列出systemd服务：systemctl list- unit- files<br>关机：shutdown now<br>重启：reboot<br>停机：halt<br>关机，断电：poweroff</p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>man：查询命令详情<br>type 判断是内置命令还是外置命令</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>运维</tag>
        <tag>系统</tag>
      </tags>
  </entry>
</search>
